<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indoor Navigation (Voice + QR)</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: #fff;
            line-height: 1.6;
            padding: 15px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 100%;
            margin: 0 auto;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
        }
        
        header {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        h1 {
            font-size: 2rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .status-bar {
            background: rgba(0, 0, 0, 0.4);
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-weight: bold;
            text-align: center;
        }
        
        .camera-container {
            position: relative;
            width: 100%;
            margin-bottom: 20px;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }
        
        #cameraPreview {
            width: 100%;
            height: 300px;
            background-color: #000;
            display: block;
            object-fit: cover;
        }
        
        .detection-frame {
            position: absolute;
            border: 3px solid #00ff00;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
            pointer-events: none;
        }
        
        .obstacle-frame {
            position: absolute;
            border: 3px solid #ff0000;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.5);
            pointer-events: none;
        }
        
        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        button {
            padding: 12px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(to right, #3498db, #2980b9);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }
        
        button:active {
            transform: translateY(2px);
            box-shadow: 0 2px 3px rgba(0, 0, 0, 0.2);
        }
        
        button.scan {
            background: linear-gradient(to right, #2ecc71, #27ae60);
        }
        
        button.stop {
            background: linear-gradient(to right, #e74c3c, #c0392b);
        }
        
        button.voice {
            background: linear-gradient(to right, #9b59b6, #8e44ad);
        }
        
        select {
            padding: 12px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            font-weight: bold;
            margin-bottom: 10px;
            width: 100%;
        }
        
        .log-container {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            height: 150px;
            overflow-y: auto;
        }
        
        .log-entry {
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .log-time {
            color: #3498db;
            font-size: 0.8rem;
        }
        
        .log-message {
            color: #fff;
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }
        
        .modal-content {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f);
            border-radius: 15px;
            padding: 20px;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        .modal-title {
            font-size: 1.5rem;
            font-weight: bold;
        }
        
        .close-modal {
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
        }
        
        .instruction {
            font-size: 1.2rem;
            margin-bottom: 10px;
            font-weight: bold;
            color: #f1c40f;
        }
        
        .destination-list {
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 20px;
        }
        
        .destination-item {
            padding: 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .destination-item:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .speech-status {
            text-align: center;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            margin-bottom: 15px;
            font-style: italic;
        }
        
        .voice-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
        }
        
        .pulse {
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        @media (min-width: 768px) {
            .container {
                max-width: 700px;
            }
            
            .controls {
                grid-template-columns: 1fr 1fr 1fr;
            }
            
            #cameraPreview {
                height: 400px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Indoor Navigation (Voice + QR)</h1>
            <div class="status-bar" id="statusMessage">Ready to start</div>
        </header>
        
        <div class="camera-container">
            <video id="cameraPreview" autoplay playsinline></video>
            <!-- QR code detection frame will be added here dynamically -->
            <!-- Obstacle detection frame will be added here dynamically -->
        </div>
        
        <div class="controls">
            <select id="colorFilter">
                <option value="any">Any Color QR</option>
                <option value="red">Red QR</option>
                <option value="green">Green QR</option>
                <option value="blue">Blue QR</option>
            </select>
            
            <button class="scan" id="startScanBtn">Start Scan</button>
            <button class="stop" id="stopScanBtn">Stop Scan</button>
            <button class="voice" id="voiceDestinationBtn">Voice Destination</button>
            <button id="showMapBtn">Show Map</button>
            <button id="refreshMicsBtn">Refresh Mics</button>
        </div>
        
        <div class="log-container" id="logContainer">
            <div class="log-entry">
                <span class="log-time">[12:00:00]</span>
                <span class="log-message"> Application started. Click Start Scan to begin.</span>
            </div>
        </div>
    </div>
    
    <!-- Navigation Modal -->
    <div class="modal" id="navigationModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Navigation</div>
                <button class="close-modal">&times;</button>
            </div>
            <div id="routeSummary"></div>
            <div class="instruction" id="currentInstruction"></div>
            <div id="currentDistance"></div>
            <div class="controls">
                <button id="nextStepBtn">Next Step</button>
                <button id="cancelNavigationBtn">Cancel Navigation</button>
            </div>
        </div>
    </div>
    
    <!-- Destination Modal -->
    <div class="modal" id="destinationModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Select Destination</div>
                <button class="close-modal">&times;</button>
            </div>
            <div id="currentLocationDisplay"></div>
            <div class="destination-list" id="destinationList"></div>
            <div class="controls">
                <button id="startNavigationBtn">Start Navigation</button>
                <button id="cancelDestinationBtn">Cancel</button>
            </div>
        </div>
    </div>
    
    <!-- Voice Listening Modal -->
    <div class="modal" id="voiceListeningModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Voice Destination</div>
                <button class="close-modal">&times;</button>
            </div>
            <div class="speech-status" id="listeningStatus">Listening... Please speak your destination</div>
            <div class="voice-controls">
                <button id="startListeningBtn">Start Listening</button>
                <button id="cancelVoiceBtn">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // Application State and Configuration
        const nodeCoords = {
            "Female Toilet (NGT1)": [2009, 1357],
            "Male Toilet (NGT2)": [1955, 1357],
            "N001 (backdoor)": [2100, 1135],
            "N001": [1907, 1121],
            "N002": [1651, 1097],
            "N003": [1387, 1074],
            "N004": [892, 1097],
            "N005": [638, 1115],
            "N006": [383, 1139],
            "N007": [127, 1158],
            "N008": [4, 1330],
            "Female Toilet (NGT5)": [357, 1350],
            "Male Toilet (NGT4)": [403, 1351],
            "N009": [492, 1330],
            "N010": [822, 1335],
            "N011": [1251, 1340],
            "N012": [1597, 1340],
        };

        const graphRaw = {
            "Female Toilet (NGT1)": {"Male Toilet (NGT2)": 1.89},
            "N001": {"Female Toilet (NGT1)": 9.00, "N001 (backdoor)": 6.77, "N002": 9.00},
            "N002": {"N003": 9.28},
            "N003": {"N004": 17.35},
            "N004": {"N005": 8.91},
            "N005": {"N006": 8.97},
            "N006": {"Male Toilet (NGT4)": 7.45, "Female Toilet (NGT5)": 7.44, "N007": 8.99},
            "N007": {"N008": 7.40},
            "N008": {"Female Toilet (NGT5)": 12.38},
            "Female Toilet (NGT5)": {"Male Toilet (NGT4)": 1.61},
            "Male Toilet (NGT4)": {"N009": 3.20},
            "N009": {"N010": 11.55},
            "N010": {"N011": 15.02},
            "N011": {"N012": 12.11},
            "N012": {"Male Toilet (NGT2)": 12.55}
        };

        // Make graph bidirectional
        const graph = {};
        for (const node in graphRaw) {
            graph[node] = {...graphRaw[node]};
        }
        for (const fromNode in graphRaw) {
            for (const toNode in graphRaw[fromNode]) {
                if (!graph[toNode]) {
                    graph[toNode] = {};
                }
                graph[toNode][fromNode] = graphRaw[fromNode][toNode];
            }
        }

        // Application state
        let state = {
            currentLocation: null,
            detectedColor: null,
            isScanning: false,
            currentNavigationTarget: null,
            navigationPath: [],
            navigationIndex: 0,
            mediaStream: null,
            speechSynthesis: window.speechSynthesis,
            recognition: null,
            qrDetectionInterval: null,
            obstacleDetectionInterval: null,
            lastObstacleAnnounce: 0,
            qrFrame: null,
            obstacleFrame: null
        };

        // UI Elements
        const elements = {
            statusMessage: document.getElementById('statusMessage'),
            cameraPreview: document.getElementById('cameraPreview'),
            logContainer: document.getElementById('logContainer'),
            colorFilter: document.getElementById('colorFilter'),
            startScanBtn: document.getElementById('startScanBtn'),
            stopScanBtn: document.getElementById('stopScanBtn'),
            voiceDestinationBtn: document.getElementById('voiceDestinationBtn'),
            showMapBtn: document.getElementById('showMapBtn'),
            refreshMicsBtn: document.getElementById('refreshMicsBtn'),
            navigationModal: document.getElementById('navigationModal'),
            destinationModal: document.getElementById('destinationModal'),
            voiceListeningModal: document.getElementById('voiceListeningModal'),
            routeSummary: document.getElementById('routeSummary'),
            currentInstruction: document.getElementById('currentInstruction'),
            currentDistance: document.getElementById('currentDistance'),
            nextStepBtn: document.getElementById('nextStepBtn'),
            cancelNavigationBtn: document.getElementById('cancelNavigationBtn'),
            currentLocationDisplay: document.getElementById('currentLocationDisplay'),
            destinationList: document.getElementById('destinationList'),
            startNavigationBtn: document.getElementById('startNavigationBtn'),
            cancelDestinationBtn: document.getElementById('cancelDestinationBtn'),
            listeningStatus: document.getElementById('listeningStatus'),
            startListeningBtn: document.getElementById('startListeningBtn'),
            cancelVoiceBtn: document.getElementById('cancelVoiceBtn')
        };

        // Close modal buttons
        document.querySelectorAll('.close-modal').forEach(button => {
            button.addEventListener('click', () => {
                document.querySelectorAll('.modal').forEach(modal => {
                    modal.style.display = 'none';
                });
            });
        });

        // Utility Functions
        function log(message) {
            const now = new Date();
            const timeString = `[${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}]`;
            
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            logEntry.innerHTML = `<span class="log-time">${timeString}</span><span class="log-message"> ${message}</span>`;
            
            elements.logContainer.appendChild(logEntry);
            elements.logContainer.scrollTop = elements.logContainer.scrollHeight;
            console.log(message);
        }

        function setStatus(message) {
            elements.statusMessage.textContent = message;
        }

        function speak(text, interrupt = false) {
            if (interrupt) {
                state.speechSynthesis.cancel();
            }
            
            const utterance = new SpeechSynthesisUtterance(text);
            state.speechSynthesis.speak(utterance);
            log(`Voice: ${text}`);
        }

        // Pathfinding Algorithm
        function dijkstra(start, end) {
            const pq = [{ cost: 0, node: start, path: [] }];
            const visited = new Set();
            
            while (pq.length > 0) {
                pq.sort((a, b) => a.cost - b.cost);
                const { cost, node, path } = pq.shift();
                
                if (visited.has(node)) continue;
                const newPath = [...path, node];
                visited.add(node);
                
                if (node === end) {
                    return { path: newPath, cost };
                }
                
                for (const neighbor in graph[node]) {
                    if (!visited.has(neighbor)) {
                        pq.push({
                            cost: cost + graph[node][neighbor],
                            node: neighbor,
                            path: newPath
                        });
                    }
                }
            }
            
            return { path: [], cost: Infinity };
        }

        // Direction Calculation
        function getTurnDirection(p1, p2, p3) {
            const v1 = [p2[0] - p1[0], p2[1] - p1[1]];
            const v2 = [p3[0] - p2[0], p3[1] - p2[1]];
            
            const angle1 = Math.atan2(v1[1], v1[0]);
            const angle2 = Math.atan2(v2[1], v2[0]);
            
            let angle = (angle2 - angle1) * 180 / Math.PI;
            angle = (angle + 360) % 360;
            
            if (angle < 45 || angle > 315) return "Move straight";
            if (angle >= 45 && angle < 135) return "Turn right";
            if (angle >= 135 && angle < 225) return "Turn back";
            return "Turn left";
        }

        function getInitialDirectionSimple(p1, p2) {
            const dx = p2[0] - p1[0];
            const dy = p2[1] - p1[1];
            let angle = Math.atan2(dy, dx) * 180 / Math.PI;
            angle = (angle + 360) % 360;
            
            if (angle >= 315 || angle < 45) return "Move straight";
            if (angle >= 45 && angle < 135) return "Turn right";
            if (angle >= 135 && angle < 225) return "Turn back";
            return "Turn left";
        }

        // QR Code Detection Simulation
        function detectQRCode() {
            // In a real implementation, this would use a QR code library
            // For simulation, we'll randomly detect QR codes
            const simulatedDetection = Math.random() < 0.1; // 10% chance of detection
            
            if (simulatedDetection) {
                const locations = Object.keys(nodeCoords);
                const randomLocation = locations[Math.floor(Math.random() * locations.length)];
                
                // Create or update QR frame
                if (!state.qrFrame) {
                    state.qrFrame = document.createElement('div');
                    state.qrFrame.className = 'detection-frame';
                    document.querySelector('.camera-container').appendChild(state.qrFrame);
                }
                
                // Position the frame randomly on the video
                const videoWidth = elements.cameraPreview.videoWidth || 640;
                const videoHeight = elements.cameraPreview.videoHeight || 480;
                const frameSize = Math.min(videoWidth, videoHeight) * 0.3;
                
                state.qrFrame.style.width = `${frameSize}px`;
                state.qrFrame.style.height = `${frameSize}px`;
                state.qrFrame.style.left = `${Math.random() * (videoWidth - frameSize)}px`;
                state.qrFrame.style.top = `${Math.random() * (videoHeight - frameSize)}px`;
                
                return {
                    found: true,
                    decoded: randomLocation,
                    color: elements.colorFilter.value,
                    guidance: "OK – close enough!",
                    bbox: {
                        x: parseInt(state.qrFrame.style.left),
                        y: parseInt(state.qrFrame.style.top),
                        width: frameSize,
                        height: frameSize
                    }
                };
            } else if (state.qrFrame) {
                // Remove the frame if no QR code is detected
                state.qrFrame.remove();
                state.qrFrame = null;
            }
            
            return {
                found: false,
                decoded: null,
                color: null,
                guidance: "Looking...",
                bbox: null
            };
        }

        // Obstacle Detection Simulation
        function detectObstacle() {
            // This is a simplified simulation of obstacle detection
            const hasObstacle = Math.random() < 0.1; // 10% chance of obstacle
            
            if (hasObstacle) {
                const distance = (Math.random() * 3).toFixed(1); // Random distance 0-3m
                
                // Create or update obstacle frame
                if (!state.obstacleFrame) {
                    state.obstacleFrame = document.createElement('div');
                    state.obstacleFrame.className = 'obstacle-frame';
                    document.querySelector('.camera-container').appendChild(state.obstacleFrame);
                }
                
                // Position the frame at the bottom center (typical obstacle location)
                const videoWidth = elements.cameraPreview.videoWidth || 640;
                const videoHeight = elements.cameraPreview.videoHeight || 480;
                const frameWidth = videoWidth * 0.6;
                const frameHeight = videoHeight * 0.2;
                
                state.obstacleFrame.style.width = `${frameWidth}px`;
                state.obstacleFrame.style.height = `${frameHeight}px`;
                state.obstacleFrame.style.left = `${(videoWidth - frameWidth) / 2}px`;
                state.obstacleFrame.style.top = `${videoHeight - frameHeight - 20}px`;
                
                return {
                    found: true,
                    distance: distance,
                    bbox: {
                        x: parseInt(state.obstacleFrame.style.left),
                        y: parseInt(state.obstacleFrame.style.top),
                        width: frameWidth,
                        height: frameHeight
                    }
                };
            } else if (state.obstacleFrame) {
                // Remove the frame if no obstacle is detected
                state.obstacleFrame.remove();
                state.obstacleFrame = null;
            }
            
            return {
                found: false,
                distance: null,
                bbox: null
            };
        }

        // Camera Management
        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        facingMode: 'environment',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    },
                    audio: false
                });
                
                elements.cameraPreview.srcObject = stream;
                state.mediaStream = stream;
                
                // Set up QR code detection interval
                state.qrDetectionInterval = setInterval(() => {
                    const result = detectQRCode();
                    
                    if (result.found && result.decoded) {
                        handleQRDetection(result.decoded, result.color);
                    }
                    
                    // Update status
                    setStatus(`Color: ${result.color || 'N/A'} | ${result.guidance}`);
                }, 1000);
                
                // Set up obstacle detection interval
                state.obstacleDetectionInterval = setInterval(() => {
                    const result = detectObstacle();
                    
                    if (result.found && result.distance <= 2.5) {
                        const now = Date.now();
                        if (now - state.lastObstacleAnnounce > 2000) {
                            speak(`Obstacle ahead ${result.distance} meters. Please be careful.`, true);
                            state.lastObstacleAnnounce = now;
                        }
                    }
                }, 1000);
                
                log("Camera started");
                setStatus("Scanning... rotate slowly to find QR");
                speak("Starting scan. Rotate slowly to find colored QR codes.");
                
            } catch (error) {
                log(`Camera error: ${error.message}`);
                setStatus("Camera error");
                speak("Unable to access camera. Please check permissions.");
            }
        }

        function stopCamera() {
            if (state.mediaStream) {
                state.mediaStream.getTracks().forEach(track => track.stop());
                state.mediaStream = null;
            }
            
            if (state.qrDetectionInterval) {
                clearInterval(state.qrDetectionInterval);
                state.qrDetectionInterval = null;
            }
            
            if (state.obstacleDetectionInterval) {
                clearInterval(state.obstacleDetectionInterval);
                state.obstacleDetectionInterval = null;
            }
            
            // Remove detection frames
            if (state.qrFrame) {
                state.qrFrame.remove();
                state.qrFrame = null;
            }
            
            if (state.obstacleFrame) {
                state.obstacleFrame.remove();
                state.obstacleFrame = null;
            }
            
            elements.cameraPreview.srcObject = null;
            log("Camera stopped");
            setStatus("Scanner stopped");
        }

        // QR Detection Handler
        function handleQRDetection(decoded, color) {
            const decodedClean = decoded.trim();
            
            // If we're navigating and this matches the target
            if (state.currentNavigationTarget) {
                if (decodedClean.toLowerCase() === state.currentNavigationTarget.toLowerCase()) {
                    log(`Arrival QR scanned for destination: ${decodedClean}`);
                    speak(`You have arrived at ${decodedClean}.`, true);
                    state.currentLocation = decodedClean;
                    state.currentNavigationTarget = null;
                    stopCamera();
                    alert(`Arrival confirmed: ${decodedClean}`);
                    return;
                } else if (decodedClean !== state.currentLocation) {
                    // Interim QR code detected during navigation
                    state.currentLocation = decodedClean;
                    state.detectedColor = color;
                    log(`Scanned interim QR: ${decodedClean} [${color}] (still navigating)`);
                    speak(`Scanned ${decodedClean}.`);
                }
                return;
            }
            
            // Not navigating - update current location
            if (decodedClean !== state.currentLocation) {
                state.currentLocation = decodedClean;
                state.detectedColor = color;
                log(`Detected location: ${decodedClean} [${color}]`);
                speak(`Detected location ${decodedClean}.`);
                setStatus(`Detected: ${decodedClean} (${color})`);
                
                // Ask for destination
                setTimeout(() => {
                    askDestinationViaVoice();
                }, 700);
            }
        }

        // Navigation Functions
        function startNavigation(destination) {
            if (!state.currentLocation) {
                alert("No current location detected. First scan a QR code.");
                return;
            }
            
            log(`Calculating route from ${state.currentLocation} to ${destination}...`);
            const { path, cost } = dijkstra(state.currentLocation, destination);
            
            if (path.length === 0 || cost === Infinity) {
                const msg = "No path found to destination.";
                log(msg);
                speak(msg);
                alert(msg);
                return;
            }
            
            state.navigationPath = path;
            state.navigationIndex = 0;
            state.currentNavigationTarget = destination;
            
            showNavigationModal(path, cost);
            
            const summaryText = `Navigation started. Total distance ${cost.toFixed(2)} meters.`;
            speak(summaryText);
            
            // Ensure camera is running for navigation
            if (!state.isScanning) {
                startCamera();
            }
        }

        function showNavigationModal(path, totalCost) {
            elements.routeSummary.innerHTML = `
                <p><strong>Route:</strong> ${path.join(' → ')}</p>
                <p><strong>Total distance:</strong> ${totalCost.toFixed(2)} meters | <strong>Waypoints:</strong> ${path.length}</p>
            `;
            
            elements.navigationModal.style.display = 'flex';
            
            showCurrentStep();
        }

        function showCurrentStep() {
            if (state.navigationIndex >= state.navigationPath.length - 1) {
                const finalText = `Proceed to scan the QR code at the destination: ${state.navigationPath[state.navigationPath.length - 1]} to confirm arrival.`;
                elements.currentInstruction.textContent = finalText;
                elements.currentDistance.textContent = "";
                elements.nextStepBtn.textContent = "Finish";
                speak(finalText);
                log("Please scan the QR at the final destination to confirm arrival.");
                return;
            }
            
            const current = state.navigationPath[state.navigationIndex];
            const nextNode = state.navigationPath[state.navigationIndex + 1];
            const distance = graph[current][nextNode];
            
            let instruction;
            if (state.navigationIndex === 0) {
                instruction = `${getInitialDirectionSimple(nodeCoords[current], nodeCoords[nextNode])} towards ${nextNode}.`;
            } else {
                const prevNode = state.navigationPath[state.navigationIndex - 1];
                instruction = `At ${current}: ${getTurnDirection(nodeCoords[prevNode], nodeCoords[current], nodeCoords[nextNode])} towards ${nextNode}.`;
            }
            
            elements.currentInstruction.textContent = instruction;
            elements.currentDistance.textContent = `Distance: ${distance.toFixed(2)} meters`;
            elements.nextStepBtn.disabled = true;
            
            speak(`${instruction} Distance ${distance.toFixed(2)} meters.`);
            
            setTimeout(() => {
                elements.nextStepBtn.disabled = false;
            }, 1000);
        }

        function nextNavigationStep() {
            if (state.navigationIndex >= state.navigationPath.length - 1) {
                closeNavigationModal();
                return;
            }
            
            state.navigationIndex++;
            showCurrentStep();
        }

        function closeNavigationModal() {
            elements.navigationModal.style.display = 'none';
            state.currentNavigationTarget = null;
        }

        // Destination Selection
        function showDestinationModal() {
            if (!state.currentLocation) {
                alert("No current location detected. First scan a QR code.");
                return;
            }
            
            elements.currentLocationDisplay.textContent = `Current location: ${state.currentLocation}`;
            elements.destinationList.innerHTML = '';
            
            const destinations = Object.keys(nodeCoords)
                .filter(n => n !== state.currentLocation)
                .map(destination => {
                    const item = document.createElement('div');
                    item.className = 'destination-item';
                    item.textContent = destination;
                    item.addEventListener('click', () => {
                        // Remove active class from all items
                        document.querySelectorAll('.destination-item').forEach(el => {
                            el.classList.remove('active');
                        });
                        // Add active class to clicked item
                        item.classList.add('active');
                    });
                    return item;
                });
            
            destinations.forEach(item => {
                elements.destinationList.appendChild(item);
            });
            
            elements.destinationModal.style.display = 'flex';
        }

        function closeDestinationModal() {
            elements.destinationModal.style.display = 'none';
        }

        function getSelectedDestination() {
            const activeItem = elements.destinationList.querySelector('.active');
            return activeItem ? activeItem.textContent : null;
        }

        // Voice Recognition
        function setupVoiceRecognition() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                log("Speech recognition not available in this browser.");
                speak("Speech recognition not available. Please use manual destination entry.");
                return false;
            }
            
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            state.recognition = new SpeechRecognition();
            state.recognition.continuous = false;
            state.recognition.interimResults = false;
            state.recognition.maxAlternatives = 3;
            
            return true;
        }

        function askDestinationViaVoice() {
            if (!state.currentLocation) {
                alert("Please scan your current location QR first.");
                return;
            }
            
            if (!setupVoiceRecognition()) {
                showDestinationModal();
                return;
            }
            
            elements.voiceListeningModal.style.display = 'flex';
            elements.listeningStatus.textContent = "Press 'Start Listening' and speak your destination";
            elements.listeningStatus.classList.remove('pulse');
        }

        function startListening() {
            if (!state.recognition) {
                setupVoiceRecognition();
            }
            
            elements.listeningStatus.textContent = "Listening... Please speak your destination";
            elements.listeningStatus.classList.add('pulse');
            
            state.recognition.onresult = (event) => {
                const speechResult = event.results[0][0].transcript;
                elements.listeningStatus.textContent = `Heard: ${speechResult}`;
                log(`Recognized speech: ${speechResult}`);
                
                processVoiceDestination(speechResult);
            };
            
            state.recognition.onerror = (event) => {
                log(`Speech recognition error: ${event.error}`);
                elements.listeningStatus.textContent = `Error: ${event.error}. Please try again.`;
                speak("Sorry, I didn't catch that. Please try again.");
                
                setTimeout(() => {
                    state.recognition.start();
                }, 2000);
            };
            
            state.recognition.onend = () => {
                elements.listeningStatus.textContent = "Listening ended. Press 'Start Listening' to try again.";
                elements.listeningStatus.classList.remove('pulse');
            };
            
            state.recognition.start();
        }

        function processVoiceDestination(spokenText) {
            const candidates = Object.keys(nodeCoords);
            let matches = [];
            
            // Simple matching
            spokenText = spokenText.toLowerCase();
            
            for (const candidate of candidates) {
                const candidateLower = candidate.toLowerCase();
                
                // Exact match
                if (candidateLower === spokenText) {
                    matches = [candidate];
                    break;
                }
                
                // Partial match
                if (candidateLower.includes(spokenText) || spokenText.includes(candidateLower)) {
                    matches.push(candidate);
                }
            }
            
            // If no matches found, try fuzzy matching
            if (matches.length === 0) {
                for (const candidate of candidates) {
                    const candidateLower = candidate.toLowerCase();
                    // Simple similarity check
                    if (calculateSimilarity(candidateLower, spokenText) > 0.5) {
                        matches.push(candidate);
                    }
                }
            }
            
            if (matches.length === 0) {
                elements.listeningStatus.textContent = "Destination not found. Please try again.";
                speak("Destination not found. Please say again.");
                
                setTimeout(() => {
                    state.recognition.start();
                }, 2000);
                return;
            }
            
            const bestMatch = matches[0];
            elements.listeningStatus.textContent = `Did you mean ${bestMatch}?`;
            speak(`Did you mean ${bestMatch}? Please say yes or no.`);
            
            // Set up confirmation listener
            const originalOnResult = state.recognition.onresult;
            state.recognition.onresult = (event) => {
                const confirmation = event.results[0][0].transcript.toLowerCase();
                log(`Confirmation speech: ${confirmation}`);
                
                if (confirmation.includes('yes') || confirmation.includes('yeah') || confirmation.includes('correct')) {
                    closeVoiceModal();
                    startNavigation(bestMatch);
                } else {
                    elements.listeningStatus.textContent = "Okay, please say the destination again.";
                    speak("Okay, please say the destination again.");
                    
                    // Reset to original listener
                    state.recognition.onresult = originalOnResult;
                    
                    setTimeout(() => {
                        state.recognition.start();
                    }, 2000);
                }
            };
            
            state.recognition.start();
        }

        function calculateSimilarity(str1, str2) {
            // Simple similarity calculation
            const longer = str1.length > str2.length ? str1 : str2;
            const shorter = str1.length > str2.length ? str2 : str1;
            
            if (longer.length === 0) return 1.0;
            
            return (longer.length - editDistance(longer, shorter)) / parseFloat(longer.length);
        }

        function editDistance(s1, s2) {
            // Levenshtein distance
            s1 = s1.toLowerCase();
            s2 = s2.toLowerCase();
            
            const costs = [];
            for (let i = 0; i <= s1.length; i++) {
                let lastValue = i;
                for (let j = 0; j <= s2.length; j++) {
                    if (i === 0) {
                        costs[j] = j;
                    } else if (j > 0) {
                        let newValue = costs[j - 1];
                        if (s1.charAt(i - 1) !== s2.charAt(j - 1)) {
                            newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1;
                        }
                        costs[j - 1] = lastValue;
                        lastValue = newValue;
                    }
                }
                if (i > 0) costs[s2.length] = lastValue;
            }
            return costs[s2.length];
        }

        function closeVoiceModal() {
            if (state.recognition) {
                state.recognition.stop();
            }
            elements.voiceListeningModal.style.display = 'none';
        }

        // Map Display
        function showMapPreview() {
            alert("Map preview would be shown here. In a full implementation, this would display the indoor map with nodes and paths.");
        }

        // Event Listeners
        elements.startScanBtn.addEventListener('click', () => {
            state.isScanning = true;
            startCamera();
        });

        elements.stopScanBtn.addEventListener('click', () => {
            state.isScanning = false;
            stopCamera();
        });

        elements.showMapBtn.addEventListener('click', showMapPreview);

        elements.voiceDestinationBtn.addEventListener('click', askDestinationViaVoice);

        elements.refreshMicsBtn.addEventListener('click', () => {
            log("Microphones refreshed");
            speak("Microphones refreshed");
        });

        elements.nextStepBtn.addEventListener('click', nextNavigationStep);

        elements.cancelNavigationBtn.addEventListener('click', closeNavigationModal);

        elements.startNavigationBtn.addEventListener('click', () => {
            const destination = getSelectedDestination();
            if (destination) {
                closeDestinationModal();
                startNavigation(destination);
            } else {
                alert("Please select a destination.");
            }
        });

        elements.cancelDestinationBtn.addEventListener('click', closeDestinationModal);

        elements.startListeningBtn.addEventListener('click', startListening);

        elements.cancelVoiceBtn.addEventListener('click', closeVoiceModal);

        // Initialization
        function init() {
            log("App started. Click Start Scan to find colored QR codes.");
            speak("Application started.");
            
            // Check for speech recognition support
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                log("Speech recognition available.");
                speak("Speech recognition available.");
            } else {
                log("Speech recognition not available.");
                speak("Speech recognition not available. Please use manual destination entry.");
            }
        }

        // Start the application
        init();
    </script>
</body>
</html>
